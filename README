Dependency injection with Windows Workflow Foundation 4 can be very complex. 

This extension allows to use property injection on Windows Workflow Activities. 

Let us quickly dive into an example how this extension can be useful. Imagine you have a workflow which does the following:

	(1) Observes a given folder for file changes. When a new file arrives in the observed folder the workflow is resumed.
	(2) The new file which is indicated by the file changed event is opened and parsed by an IParser implementation
	(3) The result is passed to the client which invoked the workflow.
	
We have the following key problems now with classical Windows Workflow Foundation:

	(1) How to get IFolderWatcher into the step which observes a given folder for file changes.
	(2) How to get IParser into the step which parses the file
	(3) For event processing we need extensions which might need external dependencies.
	(4) How to unit test WorkflowInvoker and WorkflowApplication events like Completed, Faulted etc.

    public class FileInputTransformationWorkflow : Activity
    {
        [RequiredArgument]
        public InArgument<string> Filter { get; set; }

		[RequiredArgument]
        public InArgument<string> Folder { get; set; }

        protected override Func<Activity> Implementation
        {
            get
            {
                return () =>
                    {
                        var path = new Variable<string>();
                        var parsedValues = new Variable<IDictionary<string, double>>();

                        return new Sequence
                            {
                                Variables = { path, parsedValues },
                                Activities =
                                    {
                                        new ObserveFolderStep
                                            {
                                                Folder = new InArgument<string>(env => env.GetValue(this.Folder)),
                                                Filter = new InArgument<string>(env => env.GetValue(this.Filter)),
                                                Path = new OutArgument<string>(path),
                                            },
                                        new ParseDataStep
                                            {
                                                FilePath = new InArgument<string>(path),
                                                ParsedValues = new OutArgument<IDictionary<string, double>>(parsedValues),
                                            },
										...
                                    }
                            };
                    };
            }

            set
            {
                base.Implementation = value;
            }
        }
    }
	
    public sealed class ObserveFolderStep : NativeActivity
    {
        [RequiredArgument]
        public InArgument<string> Filter { get; set; }


        [RequiredArgument]
        public InArgument<string> Folder { get; set; }

        public OutArgument<string> Path { get; set; }

        [Inject]
        public IFolderWatcher FolderWatcher { get; set; }

        protected override bool CanInduceIdle
        {
            get
            {
                return true;
            }
        }

        protected override void CacheMetadata(NativeActivityMetadata metadata)
        {
            // Tell the runtime that we need this extension
            metadata.RequireExtension(typeof(IObserveFolderExtension));

            base.CacheMetadata(metadata);
        }

        protected override void Execute(NativeActivityContext context)
        {
            var observeExtension = context.GetExtension<IObserveFolderExtension>();

            this.FolderWatcher.Folder = this.Folder.Get(context);
            this.FolderWatcher.Filter = this.Filter.Get(context);

            observeExtension.AddFileChangedCallback(this.FolderWatcher);

            this.FolderWatcher.StartObservation();

            context.CreateBookmark(observeExtension.Bookmark, this.OnFileChanged);
        }

        private void OnFileChanged(ActivityContext context, Bookmark bookmark, object value)
        {
            this.FolderWatcher.StopObservation();

            this.Path.Set(context, (string)value);
        }
	}
	
    public sealed class ParseDataStep : CodeActivity
    {
        [RequiredArgument]
        public InArgument<string> Path { get; set; }

        public OutArgument<IDictionary<string, double>> ParsedValues { get; set; }

        [Inject]
        public IParser Parser { get; set; }    

        protected override void Execute(CodeActivityContext context)
        {
            var filePath = this.Path.Get(context);

            var result = this.Parser.Parse(filePath);

            this.ParsedValues.Set(context, result);
        }
    }
	
How to hook into the injection chain?

this.Bind<IActivityInjectorExtension>().To<YourExtension>();

The extensions are collected upon creation of the IActivityInjector. The order of the extension invocation is not predictable.	